[TOC]



# 一、基础算法

## 1.1 火车头

```C++
#include<bits/stdc++.h>
#define int long long
#define QwQ return 0;
#define awa return
#define fios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define EPS 1e-8
#define INF 0x7fffffff
#define DEBUG "L= "<< setw(2)<< __LINE__ << ":  "
#ifdef DEBUG
#define print(a) cout<<DEBUG<<#a << ": " <<(a)<<endl
#define prin2(a, b) cout <<DEBUG<<":  "<< #a<<": "<< (a)<<" "<<#b<< ": "<<(b)<<endl
#define prinl(a) do{cout<<DEBUG<<endl;int s=min((int)a.size(),(int)16);for(int i=0;i<s;i++)cout<<setw(4)<<i<<" \n"[i==s-1];int num=0;for(auto i:a){cout<<setw(4)<<i<<"\n "[bool(++num%s)];}cout<<endl;}while(0)
#endif
using namespace std;
const int CJR=998244353;
const int maxn=2e5+1e3;

void solve()
{

}

signed main()
{
	fios
	int _=1;
	cin>>_;
	while(_--) solve();
	QwQ
}
```



## 1.2 二分

### 1.2.1 整数域



```c++

```



### 1.2.2 实数域



```c++

```



## 1.3 三分

### 1.3.1 整数域



```c++

```



### 1.3.2 实数域



```c++

```





# 二、图论

## 2.1 常见概念



## 2.2 单源最短路径

### 2.2.1 （正权稀疏图）动态数组+Dijkstra



```c++

```

### 2.2.2 （负权图）SPFA



```c++

```



## 2.3 多源最短路径

### 2.3.1 （稠密图）邻接矩阵+Floyd



```c++

```



## 2.4 平面图最短路（对偶图）



```c++

```



## 2.5 最小生成树

### 2.5.1 （稀疏图）Prim



```c++

```



### 2.5.2 （稠密图）Kruskal



```c++

```



## 2.6 缩点（Tarjan）

### 2.6.1 （有向图）强连通分量缩点



```c++

```



### 2.6.2 （无向图）割边缩点-边双连通



```c++

```



### 2.6.3 （无向图）割点缩点-点双连通



```c++

```



## 2.7 染色法判定二分图（DFS）



```c++

```



## 2.8 链式前向星建图与搜索



```c++

```



# 三、图论plus与网络流

## 3.1 一般图

### 3.1.1 一般图最大匹配（带花树）



```c++

```



### 3.1.2 一般图最大权匹配（带权带花树）



```c++

```



## 3.2 二分图

### 3.2.1 最大匹配匈牙利算法（KM算法）



```c++

```



### 3.2.2 最大匹配Hopcroft Karp算法（基于最大流的HK算法）

 

```c++

```



### 3.2.3 最大权匹配（完美匹配）



```c++

```



### 3.2.4 最大独立点集（König定理）



```c++

```



## 3.3 最长路（top sort+DP）



```c++

```



## 3.4 最短路径树（SPT）



```c++

```



## 3.5 全局最小割



```c++

```



## 3.6 欧拉回路

### 3.6.1 有向图欧拉路径存在判定



### 3.6.2 无向图欧拉路径存在判定



### 3.6.3 有向图欧拉路径求解（字典序最小）



### 3.6.4 无向图欧拉路径求解



## 3.7 差分约束



## 3.8 图论2-SAT

### 3.8.1 封装



### 3.8.2 Plus



## 3.9 最大流



## 3.10 最小割



## 3.11 费用流



## 3.12 常见结论



## 3.13 常见例题





# 四、树论与数据结构

## 4.1 封装（直径+重心+中心）



```c++

```



## 4.2 树的直径



```c++

```



## 4.3 点分治 / 树的重心



```c++

```



## 4.4 最近公共祖先 LCA

### 4.4.1 树链剖分解法



```c++

```



### 4.4.2 树上倍增解法



```c++

```



## 4.5 树上启发式合并（DSU on tree）



```c++

```



## 4.6 并查集



## 4.7 树状数组

### 4.7.1 封装



### 4.7.2 求解逆序对



### 4.7.3 二维树状数组



## 4.8 线段树

### 4.8.1 区间加、改、最值、合并



### 4.8.2 区间乘、取模



## 4.9 坐标压缩和离散化



# 五、树论plus

## 5.1 轻重链剖分



## 5.2 莫队



## 5.3 分数运算



## 5.4 主席树



## 5.5 KD-Tree



## 5.6 ST表



## 5.7 基于状压的线性RMQ



## 5.8 平衡二叉树



## 5.9 线性





# 六、动态规划







# 七、字符串







# 八、数论







# 九、多项式







# 十、几何







# 十一、概率与博弈论







# 十二、常见例题







# 十三、STL与库函数







# 十四、其他杂类





