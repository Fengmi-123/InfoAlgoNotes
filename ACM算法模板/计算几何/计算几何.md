# 计算几何

这里主要是最近遇到的计算几何中比较在能力范围内的板子和技巧

## 板子

```c++
struct Point{
    ll x, y;
    bool operator<(const Point &p) const {
        return x != p.x ? x < p.x : y < p.y;
    }
    bool operator==(const Point &p) const { return x == p.x && y == p.y; }
    Point operator-(const Point &p) const { return {x - p.x, y - p.y}; }
};//定义一个点及其运算

ll cx(Point a,Point b){//可使用__int128防止爆ll
    return a.x*b.y-a.y*b.x;
}//叉乘 cross
bool check(Point a,Point b,Point c){
    return cx(b-a,c-b)==0;
}//判断三点共线
bool zuo(Point a,Point b,Point c){
    return cx(b-a,c-b)>0;
}//判断三点构成的两条线段左转
bool you(Point a,Point b,Point c){
    return cx(b-a,c-b)<0;
}//判断三点构成的两条线段左转
bool cmp(ANS a,ANS b){
    if(a.x==b.x) return a.y<b.y;
    else return a.x<b.x;
}//比较 建立凸包必备
```

## 小技巧：判断一个给定的多边形是顺时针的还是逆时针的

```c++
__int128 sum=0;
for(ll i=0;i<n;i++){
     sum+=cx(p[i],p[(i+1)%n]);
}
```

若 $sum>0$ 则给出多边形是 逆时针 $(CCW)$ 若 $sum<0$ 则给出多边形是 顺时针 $(CW)$



## Andrew 算法

用于寻找凸包 复杂度 $O(nlogn)$ 主要复杂度在排序，每个点入队次数为 $2$

```c++
vector<Point> andrew(vector<Point> e){
    sort(e.begin(),e.end());
    vector<Point> gl;
    for(ll i=0;i<e.size();i++){//上凸壳
        while(gl.size()>=2 && cx(gl[gl.size()-1]-gl[gl.size()-2], e[i]-gl[gl.size()-1]) <=0){
            gl.pop_back();
        }//若判断条件为=则去除共线的点作为凸包 去掉=即去掉共线的点，保留端点
        gl.push_back(e[i]);
    }
    ll t=gl.size();
    for(ll i=(ll)e.size()-2;i>=0;i--){//下凸壳
        while(gl.size()>t && cx(gl[gl.size()-1]-gl[gl.size()-2], e[i]-gl[gl.size()-1]) <= 0){
            gl.pop_back();
        }
        gl.push_back(e[i]);
    }
    if(!gl.empty()) gl.pop_back();//删去首尾都会加上的重复的点
    return gl;
}
```
